
	INCLUDE equates.s
	INCLUDE 6502mac.s

	IMPORT NES_RAM		 ;nes_main.c   __align(1024) uint8 NES_RAM[0x800];//保持1024字节对齐
	IMPORT NES_SRAM		 ;nes_main.c   uint8 NES_SRAM[0x2000];	
	IMPORT spr_ram		 ;             uint8 spr_ram[0x100];

	EXPORT cpunmi    ;cpu中断标志
	EXPORT cpuirq    ;cpu中断标志 
	EXPORT clocks    ;apu要的cpu时钟
	EXPORT cpu_data	   ;地址 cart.s
	EXPORT NMI6502
	EXPORT CPU_reset
	EXPORT run6502
	EXPORT op_table	

IRQ_VECTOR		EQU 0xfffe ; //IRQ / BRK中断向量地址
RES_VECTOR		EQU 0xfffc ;// 复位中断向量地址
NMI_VECTOR		EQU 0xfffa ;// NMI中断向量地址

;cycle flags- (stored in cycles reg for speed)存储在周期章速度

CYC_C			EQU 0x01	;Carry bit 进位
;BRANCH			EQU 0x02	;branch instruction encountered	遇到分支指令
CYC_I			EQU 0x04	;IRQ mask
CYC_D			EQU 0x08	;Decimal bit	小数位
CYC_V			EQU 0x40	;Overflow bit	 溢出位
;CYC_MASK		EQU 0xFF;CYCLE-1	;Mask

   AREA cpu_code, CODE, READONLY ;, ALIGN=2
											;	不要对 ARM 代码节使用 ALIGN=0 或 ALIGN=1。
                                           ;    不要对 Thumb 代码节使用 ALIGN=0。
   ;AREA  伪代码也是需要语法的，AREA  后面跟着段名标号，然后是属性，CODE 表示这是一 
	;个代码段，READONLY 表示这个段是只读的
	;|.text|系统默认的代码段名  
	; ALIGN 指令通过用零或 NOP 指令进行填充将当前位置对齐到指定边界
	;ENTRY  这个伪代码是用来定义入口点
	THUMB	 ;Thumb是ARM体系结构中一种16位的指令集
;	REQUIRE8  ;REQUIRE8 指令指定当前文件要求堆栈八字节对齐。 它设置 REQ8 编译属性以通知链接器。
	PRESERVE8 ;{TRUE} ;PRESERVE8 指令指定当前文件保持堆栈八字节对齐。 它设置 PRES8 编译属性以通知链接器。
			  ;如果您省略 PRESERVE8 和 PRESERVE8 {FALSE}，汇编程序会检查修改 sp 的指令，
			  ;以决定是否设置 PRES8 编译属性。 ARM 建议明确指定 PRESERVE8。
			  ; ARM使用r0作为返回值
			  ;参数传递ARM：寄存器到堆栈，首先将参数赋给r0, r1等

 ;  PROC 为子程序开始，ENDP 为子程序结束


		;r0,r1,r2=temp regs	  
m6502_nz	RN r3 ;bit 31=N, Z=1 if bits 0-7=0		  ;RN定义寄存器名
m6502_rmem	RN r4 ;readmem_tbl
m6502_a		RN r5 ;//bits 0-23=0, 还用于清除在内存中的字节
m6502_x		RN r6 ;bits 0-23=0
m6502_y		RN r7 ;bits 0-23=0
cycles		RN r8 ;//also VDIC flags也VDIC标志
m6502_pc	RN r9
globalptr	RN r10 ;=wram_globals* ptr
m6502_optbl	RN r10
cpu_zpage	RN r11 ;=CPU_RAM
addy		RN r12 ;//keep this at r12 (从头 APCS)	//addr  :代表8位地址 
		;r13=SP
		;r14=LR
		;r15=PC
;---------------------------------------------------
	

_00;   BRK
;----------------------------------------------------------------------------

	ldr r0,lastbank		 ;	  6502PC从 ROM的最后偏移量
	sub r1,m6502_pc,r0
	add r0,r1,#1
	push16			;save PC

	encodeP (B+R)		;save P

	ldr r12,=IRQ_VECTOR
	bl VecCont

	fetch 7
	LTORG			 ;指令， LTORG可能是在一个可执行的位置
;----------------------------------------------------------------------------
_01;   ORA ($nn,X)
;----------------------------------------------------------------------------
	doIIX
	opORA
	fetch 6
;----------------------------------------------------------------------------
_05;   ORA $nn
;----------------------------------------------------------------------------
	doZ
	opORA
	fetch 3
;----------------------------------------------------------------------------
_06;   ASL $nn
;----------------------------------------------------------------------------
	doZ
	opASL
	fetch_c 5
;----------------------------------------------------------------------------
_08;   PHP
;----------------------------------------------------------------------------
	encodeP (B+R)
	push8 r0
	fetch 3
;----------------------------------------------------------------------------
_09;   ORA #$nn
;----------------------------------------------------------------------------
	doIMM
	opORA
	fetch 2
;----------------------------------------------------------------------------
_0A;   ASL
;----------------------------------------------------------------------------
	adds m6502_a,m6502_a,m6502_a
	mov m6502_nz,m6502_a,asr#24		;NZ
	orr cycles,cycles,#CYC_C		;Prepare C
	fetch_c 2						;also subs carry
;----------------------------------------------------------------------------
_0D;   ORA $nnnn
;----------------------------------------------------------------------------
	doABS
	opORA
	fetch 4
;----------------------------------------------------------------------------
_0E;   ASL $nnnn
;----------------------------------------------------------------------------
	doABS
	opASL
	fetch_c 6
;----------------------------------------------------------------------------	 
_10;   BPL *
;----------------------------------------------------------------------------
	tst m6502_nz,#0x80000000
	ldrsb r0,[m6502_pc],#1
	addeq m6502_pc,m6502_pc,r0
;	subeq cycles,cycles,#3*CYCLE
	subeq cycles,cycles,#256
	fetch 2
;----------------------------------------------------------------------------
_11;   ORA ($nn),Y
;----------------------------------------------------------------------------
	doIIY
	opORA
	fetch 5
;----------------------------------------------------------------------------
_15;   ORA $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opORA
	fetch 4
;----------------------------------------------------------------------------
_16;   ASL $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opASL
	fetch_c 6
;----------------------------------------------------------------------------
_18;   CLC
;----------------------------------------------------------------------------
	bic cycles,cycles,#CYC_C
	fetch 2
;----------------------------------------------------------------------------
_19;   ORA $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opORA
	fetch 4
;----------------------------------------------------------------------------
_1D;   ORA $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opORA
	fetch 4
;----------------------------------------------------------------------------
_1E;   ASL $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opASL
	fetch_c 7
;----------------------------------------------------------------------------
_20;   JSR $nnnn
;----------------------------------------------------------------------------
	ldrb r2,[m6502_pc],#1
	ldr r1,lastbank
	sub r0,m6502_pc,r1
	ldrb r1,[m6502_pc]
	orr m6502_pc,r2,r1,lsl#8
	push16
	encodePC
	fetch 6
;----------------------------------------------------------------------------
_21;   AND ($nn,X)
;----------------------------------------------------------------------------
	doIIX
	opAND
	fetch 6
;----------------------------------------------------------------------------
_24;   BIT $nn
;----------------------------------------------------------------------------
	doZ
	opBIT
	fetch 3
;----------------------------------------------------------------------------
_25;   AND $nn
;----------------------------------------------------------------------------
	doZ
	opAND
	fetch 3
;----------------------------------------------------------------------------
_26;   ROL $nn
;----------------------------------------------------------------------------
	doZ
	opROL
	fetch 5
;----------------------------------------------------------------------------
_28;   PLP
;----------------------------------------------------------------------------
	pop8 r0
	decodeP
	fetch 4
;----------------------------------------------------------------------------
_29;   AND #$nn
;----------------------------------------------------------------------------
	doIMM
	opAND
	fetch 2
;----------------------------------------------------------------------------
_2A;   ROL
;----------------------------------------------------------------------------
	movs cycles,cycles,lsr#1		;get C
	orrcs m6502_a,m6502_a,#0x00800000
	adds m6502_a,m6502_a,m6502_a
	mov m6502_nz,m6502_a,asr#24		;NZ
	adc cycles,cycles,cycles		;Set C
	fetch 2
;----------------------------------------------------------------------------
_2C;   BIT $nnnn
;----------------------------------------------------------------------------
	doABS
	opBIT
	fetch 4
;----------------------------------------------------------------------------
_2D;   AND $nnnn
;----------------------------------------------------------------------------
	doABS
	opAND
	fetch 4
;----------------------------------------------------------------------------
_2E;   ROL $nnnn
;----------------------------------------------------------------------------
	doABS
	opROL
	fetch 6
;----------------------------------------------------------------------------
_30;   BMI *
;----------------------------------------------------------------------------
	tst m6502_nz,#0x80000000
	ldrsb r0,[m6502_pc],#1
	addne m6502_pc,m6502_pc,r0
;	subne cycles,cycles,#3*CYCLE
	subne cycles,cycles,#256
	fetch 2
;----------------------------------------------------------------------------
_31;   AND ($nn),Y
;----------------------------------------------------------------------------
	doIIY
	opAND
	fetch 5
;----------------------------------------------------------------------------
_35;   AND $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opAND
	fetch 4
;----------------------------------------------------------------------------
_36;   ROL $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opROL
	fetch 6
;----------------------------------------------------------------------------
_38;   SEC
;----------------------------------------------------------------------------
	orr cycles,cycles,#CYC_C
	fetch 2
;----------------------------------------------------------------------------
_39;   AND $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opAND
	fetch 4
;----------------------------------------------------------------------------
_3D;   AND $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opAND
	fetch 4
;----------------------------------------------------------------------------
_3E;   ROL $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opROL
	fetch 7
;----------------------------------------------------------------------------
_40;   RTI
;----------------------------------------------------------------------------
	pop8 r0		;pop 6502 flags and decode
	decodeP
	pop16		;pop the return address
	encodePC
	fetch 6
;----------------------------------------------------------------------------
_41;   EOR ($nn,X)
;----------------------------------------------------------------------------
	doIIX
	opEOR
	fetch 6
;----------------------------------------------------------------------------
_45;   EOR $nn
;----------------------------------------------------------------------------
	doZ
	opEOR
	fetch 3
;----------------------------------------------------------------------------
_46;   LSR $nn
;----------------------------------------------------------------------------
	doZ
	opLSR
	fetch_c 5
;----------------------------------------------------------------------------
_48;   PHA
;----------------------------------------------------------------------------
	mov r0,m6502_a,lsr#24
	push8 r0
	fetch 3
;----------------------------------------------------------------------------
_49;   EOR #$nn
;----------------------------------------------------------------------------
	doIMM
	opEOR
	fetch 2
;----------------------------------------------------------------------------
_4A;   LSR
;----------------------------------------------------------------------------
	movs m6502_nz,m6502_a,lsr#25	;Z, N=0
	mov m6502_a,m6502_nz,lsl#24		;result without garbage
	orr cycles,cycles,#CYC_C		;Prepare C
	fetch_c 2
;----------------------------------------------------------------------------
_4C;   JMP $nnnn
;----------------------------------------------------------------------------
	ldrb r0,[m6502_pc],#1
	ldrb r1,[m6502_pc]
	orr m6502_pc,r0,r1,lsl#8
	encodePC
	fetch 3
;----------------------------------------------------------------------------
_4D;   EOR $nnnn
;----------------------------------------------------------------------------
	doABS
	opEOR
	fetch 4
;----------------------------------------------------------------------------
_4E;   LSR $nnnn
;----------------------------------------------------------------------------
	doABS
	opLSR
	fetch_c 6
;----------------------------------------------------------------------------
_50;   BVC *
;----------------------------------------------------------------------------
	tst cycles,#CYC_V
	ldrsb r0,[m6502_pc],#1
	addeq m6502_pc,m6502_pc,r0
;	subeq cycles,cycles,#3*CYCLE
	subeq cycles,cycles,#256
	fetch 2
;----------------------------------------------------------------------------
_51;   EOR ($nn),Y
;----------------------------------------------------------------------------
	doIIY
	opEOR
	fetch 5
;----------------------------------------------------------------------------
_55;   EOR $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opEOR
	fetch 4
;----------------------------------------------------------------------------
_56;   LSR $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opLSR
	fetch_c 6
;----------------------------------------------------------------------------
_58;   CLI
;----------------------------------------------------------------------------
	bic cycles,cycles,#CYC_I
	fetch 2
;----------------------------------------------------------------------------
_59;   EOR $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opEOR
	fetch 4
;----------------------------------------------------------------------------
_5D;   EOR $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opEOR
	fetch 4
;----------------------------------------------------------------------------
_5E;   LSR $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opLSR
	fetch_c 7
;----------------------------------------------------------------------------
_60;   RTS
;----------------------------------------------------------------------------
	pop16
	add m6502_pc,m6502_pc,#1
	encodePC
	fetch 6
;----------------------------------------------------------------------------
_61;   ADC ($nn,X)
;----------------------------------------------------------------------------
	doIIX
	opADC
	fetch_c 6
;----------------------------------------------------------------------------
_65;   ADC $nn
;----------------------------------------------------------------------------
	doZ
	opADC
	fetch_c 3
;----------------------------------------------------------------------------
_66;   ROR $nn
;----------------------------------------------------------------------------
	doZ
	opROR
	fetch 5
;----------------------------------------------------------------------------
_68;   PLA
;----------------------------------------------------------------------------
	pop8 m6502_nz
	mov m6502_a,m6502_nz,lsl#24
	fetch 4
;----------------------------------------------------------------------------
_69;   ADC #$nn
;----------------------------------------------------------------------------
	doIMM
	opADC
	fetch_c 2
;----------------------------------------------------------------------------
_6A;   ROR
;----------------------------------------------------------------------------
	movs cycles,cycles,lsr#1		;get C
	mov m6502_a,m6502_a,rrx
	movs m6502_nz,m6502_a,asr#24	;NZ
	and m6502_a,m6502_a,#0xff000000
	adc cycles,cycles,cycles		;Set C
	fetch 2
;----------------------------------------------------------------------------
_6C;   JMP ($nnnn)	JMP ($data16) 间接寻址 *********************************
;----------------------------------------------------------------------------		
	doABS       
	adr r1,memmap_tbl			   
	and r2,addy,#0xE000	;		  
;	ldr r1,[r1,r2,lsr#11]  		  ;>>11 addr&0x7FF
	lsr r0,r2,#11			  
	ldr r1,[r1,r0]		   ;在数据传送之前,将偏移量加到Rn 中,其结果作为传送数据的存储地址
							   
	ldrb m6502_pc,[r1,addy]     ;//若使用后缀"!",则结果写回到Rn中
	add r1,r1,addy	    

	ldrb r0,[r1,#1]	    
	orr m6502_pc,m6502_pc,r0,lsl#8	 ;m6502_pc=r9使用ORR 指令将近R9的高8 位数据移入到R0低8位
	encodePC	
	fetch 5
;----------------------------------------------------------------------------
_6D;   ADC $nnnn
;----------------------------------------------------------------------------
	doABS
	opADC
	fetch_c 4
;----------------------------------------------------------------------------
_6E;   ROR $nnnn
;----------------------------------------------------------------------------
	doABS
	opROR
	fetch 6
;----------------------------------------------------------------------------
_70;   BVS *
;----------------------------------------------------------------------------
	tst cycles,#CYC_V
	ldrsb r0,[m6502_pc],#1
	addne m6502_pc,m6502_pc,r0
;	subne cycles,cycles,#3*CYCLE
	subne cycles,cycles,#256
	fetch 2
;----------------------------------------------------------------------------
_71;   ADC ($nn),Y
;----------------------------------------------------------------------------
	doIIY
	opADC
	fetch_c 5
;----------------------------------------------------------------------------
_75;   ADC $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opADC
	fetch_c 4
;----------------------------------------------------------------------------
_76;   ROR $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opROR
	fetch 6
;----------------------------------------------------------------------------
_78;   SEI
;----------------------------------------------------------------------------
	orr cycles,cycles,#CYC_I
	fetch 2
;----------------------------------------------------------------------------
_79;   ADC $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opADC
	fetch_c 4
;----------------------------------------------------------------------------
_7D;   ADC $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opADC
	fetch_c 4
;----------------------------------------------------------------------------
_7E;   ROR $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opROR
	fetch 7
;----------------------------------------------------------------------------
_81;   STA ($nn,X)
;----------------------------------------------------------------------------
	doIIX
	opSTORE m6502_a
	fetch 6
;----------------------------------------------------------------------------
_84;   STY $nn
;----------------------------------------------------------------------------
	doZ
	opSTORE m6502_y
	fetch 3
;----------------------------------------------------------------------------
_85;   STA $nn
;----------------------------------------------------------------------------
	doZ
	opSTORE m6502_a
	fetch 3
;----------------------------------------------------------------------------
_86;   STX $nn
;----------------------------------------------------------------------------
	doZ
	opSTORE m6502_x
	fetch 3
;----------------------------------------------------------------------------
_88;   DEY
;----------------------------------------------------------------------------
	sub m6502_y,m6502_y,#0x01000000
	mov m6502_nz,m6502_y,asr#24
	fetch 2
;----------------------------------------------------------------------------
_8A;   TXA
;----------------------------------------------------------------------------
	mov m6502_a,m6502_x
	mov m6502_nz,m6502_x,asr#24
	fetch 2
;----------------------------------------------------------------------------
_8C;   STY $nnnn
;----------------------------------------------------------------------------
	doABS
	opSTORE m6502_y
	fetch 4
;----------------------------------------------------------------------------
_8D;   STA $nnnn
;----------------------------------------------------------------------------
	doABS
	opSTORE m6502_a	  
	fetch 4
;----------------------------------------------------------------------------
_8E;   STX $nnnn
;----------------------------------------------------------------------------
	doABS
	opSTORE m6502_x
	fetch 4
;----------------------------------------------------------------------------
_90;   BCC *
;----------------------------------------------------------------------------
	tst cycles,#CYC_C			;Test Carry
	ldrsb r0,[m6502_pc],#1
	addeq m6502_pc,m6502_pc,r0
;	subeq cycles,cycles,#3*CYCLE
	subeq cycles,cycles,#256
	fetch 2
;----------------------------------------------------------------------------
_91;   STA ($nn),Y
;----------------------------------------------------------------------------
	doIIY
	opSTORE m6502_a
	fetch 6
;----------------------------------------------------------------------------
_94;   STY $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opSTORE m6502_y
	fetch 4
;----------------------------------------------------------------------------
_95;   STA $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opSTORE m6502_a
	fetch 4
;----------------------------------------------------------------------------
_96;   STX $nn,Y
;----------------------------------------------------------------------------
	doZIYf
	opSTORE m6502_x
	fetch 4
;----------------------------------------------------------------------------
_98;   TYA
;----------------------------------------------------------------------------
	mov m6502_a,m6502_y
	mov m6502_nz,m6502_y,asr#24
	fetch 2
;----------------------------------------------------------------------------
_99;   STA $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opSTORE m6502_a
	fetch 5
;----------------------------------------------------------------------------
_9A;   TXS
;----------------------------------------------------------------------------
	mov r0,m6502_x,lsr#24
	strb r0,m6502_s
	fetch 2
;----------------------------------------------------------------------------
_9D;   STA $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opSTORE m6502_a
	fetch 5
;----------------------------------------------------------------------------
_A0;   LDY #$nn
;----------------------------------------------------------------------------
	doIMM
	opLOAD m6502_y
	fetch 2
;----------------------------------------------------------------------------
_A1;   LDA ($nn,X)
;----------------------------------------------------------------------------
	doIIX
	opLOAD m6502_a
	fetch 6
;----------------------------------------------------------------------------
_A2;   LDX #$nn
;----------------------------------------------------------------------------
	doIMM
	opLOAD m6502_x
	fetch 2
;----------------------------------------------------------------------------
_A4;   LDY $nn
;----------------------------------------------------------------------------
	doZ
	opLOAD m6502_y
	fetch 3
;----------------------------------------------------------------------------
_A5;   LDA $nn
;----------------------------------------------------------------------------
	doZ
	opLOAD m6502_a
	fetch 3
;----------------------------------------------------------------------------
_A6;   LDX $nn
;----------------------------------------------------------------------------
	doZ
	opLOAD m6502_x
	fetch 3
;----------------------------------------------------------------------------
_A8;   TAY
;----------------------------------------------------------------------------
	mov m6502_y,m6502_a
	mov m6502_nz,m6502_y,asr#24
	fetch 2
;----------------------------------------------------------------------------
_A9;   LDA #$nn
;----------------------------------------------------------------------------
	doIMM
	opLOAD m6502_a
	fetch 2
;----------------------------------------------------------------------------
_AA;   TAX
;----------------------------------------------------------------------------
	mov m6502_x,m6502_a
	mov m6502_nz,m6502_x,asr#24
	fetch 2
;----------------------------------------------------------------------------
_AC;   LDY $nnnn
;----------------------------------------------------------------------------
	doABS
	opLOAD m6502_y
	fetch 4
;----------------------------------------------------------------------------
_AD;   LDA $nnnn
;----------------------------------------------------------------------------
	doABS
	opLOAD m6502_a
	fetch 4
;----------------------------------------------------------------------------
_AE;   LDX $nnnn
;----------------------------------------------------------------------------
	doABS
	opLOAD m6502_x
	fetch 4
;----------------------------------------------------------------------------
_B0;   BCS *
;----------------------------------------------------------------------------
	tst cycles,#CYC_C			;Test Carry
	ldrsb r0,[m6502_pc],#1
	addne m6502_pc,m6502_pc,r0
;	subne cycles,cycles,#3*CYCLE
	subne cycles,cycles,#256
	fetch 2
;----------------------------------------------------------------------------
_B1;   LDA ($nn),Y
;----------------------------------------------------------------------------
	doIIY
	opLOAD m6502_a
	fetch 5
;----------------------------------------------------------------------------
_B4;   LDY $nn,X
;----------------------------------------------------------------------------
	doZIX
	opLOAD m6502_y
	fetch 4
;----------------------------------------------------------------------------
_B5;   LDA $nn,X
;----------------------------------------------------------------------------
	doZIX
	opLOAD m6502_a
	fetch 4
;----------------------------------------------------------------------------
_B6;   LDX $nn,Y
;----------------------------------------------------------------------------
	doZIY
	opLOAD m6502_x
	fetch 4
;----------------------------------------------------------------------------
_B8;   CLV
;----------------------------------------------------------------------------
	bic cycles,cycles,#CYC_V
	fetch 2
;----------------------------------------------------------------------------
_B9;   LDA $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opLOAD m6502_a
	fetch 4
;----------------------------------------------------------------------------
_BA;   TSX
;----------------------------------------------------------------------------
	ldrb m6502_x,m6502_s
	mov m6502_x,m6502_x,lsl#24
	mov m6502_nz,m6502_x,asr#24
	fetch 2
;----------------------------------------------------------------------------
_BC;   LDY $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opLOAD m6502_y
	fetch 4
;----------------------------------------------------------------------------
_BD;   LDA $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opLOAD m6502_a
	fetch 4
;----------------------------------------------------------------------------
_BE;   LDX $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opLOAD m6502_x
	fetch 4
;----------------------------------------------------------------------------
_C0;   CPY #$nn
;----------------------------------------------------------------------------
	doIMM
	opCOMP m6502_y
	fetch_c 2
;----------------------------------------------------------------------------
_C1;   CMP ($nn,X)
;----------------------------------------------------------------------------
	doIIX
	opCOMP m6502_a
	fetch_c 6
;----------------------------------------------------------------------------
_C4;   CPY $nn
;----------------------------------------------------------------------------
	doZ
	opCOMP m6502_y
	fetch_c 3
;----------------------------------------------------------------------------
_C5;   CMP $nn
;----------------------------------------------------------------------------
	doZ
	opCOMP m6502_a
	fetch_c 3
;----------------------------------------------------------------------------
_C6;   DEC $nn
;----------------------------------------------------------------------------
	doZ
	opDEC
	fetch 5
;----------------------------------------------------------------------------
_C8;   INY
;----------------------------------------------------------------------------
	add m6502_y,m6502_y,#0x01000000
	mov m6502_nz,m6502_y,asr#24
	fetch 2
;----------------------------------------------------------------------------
_C9;   CMP #$nn
;----------------------------------------------------------------------------
	doIMM
	opCOMP m6502_a
	fetch_c 2
;----------------------------------------------------------------------------
_CA;   DEX
;----------------------------------------------------------------------------
	sub m6502_x,m6502_x,#0x01000000
	mov m6502_nz,m6502_x,asr#24
	fetch 2
;----------------------------------------------------------------------------
_CC;   CPY $nnnn
;----------------------------------------------------------------------------
	doABS
	opCOMP m6502_y
	fetch_c 4
;----------------------------------------------------------------------------
_CD;   CMP $nnnn
;----------------------------------------------------------------------------
	doABS
	opCOMP m6502_a
	fetch_c 4
;----------------------------------------------------------------------------
_CE;   DEC $nnnn
;----------------------------------------------------------------------------
	doABS
	opDEC
	fetch 6
;----------------------------------------------------------------------------
_D0;   BNE *
;----------------------------------------------------------------------------
	tst m6502_nz,#0xff
	ldrsb r0,[m6502_pc],#1
	addne m6502_pc,m6502_pc,r0
;	subne cycles,cycles,#3*CYCLE
	subne cycles,cycles,#256
	fetch 2
;----------------------------------------------------------------------------
_D1;   CMP ($nn),Y
;----------------------------------------------------------------------------
	doIIY
	opCOMP m6502_a
	fetch_c 5
;----------------------------------------------------------------------------
_D5;   CMP $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opCOMP m6502_a
	fetch_c 4
;----------------------------------------------------------------------------
_D6;   DEC $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opDEC
	fetch 6
;----------------------------------------------------------------------------
_D8;   CLD
;----------------------------------------------------------------------------
	bic cycles,cycles,#CYC_D
	fetch 2
;----------------------------------------------------------------------------
_D9;   CMP $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opCOMP m6502_a
	fetch_c 4
;----------------------------------------------------------------------------
_DD;   CMP $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opCOMP m6502_a
	fetch_c 4
;----------------------------------------------------------------------------
_DE;   DEC $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opDEC
	fetch 7
;----------------------------------------------------------------------------
_E0;   CPX #$nn
;----------------------------------------------------------------------------
	doIMM
	opCOMP m6502_x
	fetch_c 2
;----------------------------------------------------------------------------
_E1;   SBC ($nn,X)
;----------------------------------------------------------------------------
	doIIX
	opSBC
	fetch_c 6
;----------------------------------------------------------------------------
_E4;   CPX $nn
;----------------------------------------------------------------------------
	doZ
	opCOMP m6502_x
	fetch_c 3
;----------------------------------------------------------------------------
_E5;   SBC $nn
;----------------------------------------------------------------------------
	doZ
	opSBC
	fetch_c 3
;----------------------------------------------------------------------------
_E6;   INC $nn
;----------------------------------------------------------------------------
	doZ
	opINC
	fetch 5
;----------------------------------------------------------------------------
_E8;   INX
;----------------------------------------------------------------------------
	add m6502_x,m6502_x,#0x01000000
	mov m6502_nz,m6502_x,asr#24
	fetch 2
;----------------------------------------------------------------------------
_E9;   SBC #$nn
;----------------------------------------------------------------------------
	doIMM
	opSBC
	fetch_c 2
;----------------------------------------------------------------------------
_EA;   NOP
;----------------------------------------------------------------------------
	fetch 2
;----------------------------------------------------------------------------
_EC;   CPX $nnnn
;----------------------------------------------------------------------------
	doABS
	opCOMP m6502_x
	fetch_c 4
;----------------------------------------------------------------------------
_ED;   SBC $nnnn
;----------------------------------------------------------------------------
	doABS
	opSBC
	fetch_c 4
;----------------------------------------------------------------------------
_EE;   INC $nnnn
;----------------------------------------------------------------------------
	doABS
	opINC
	fetch 6
;----------------------------------------------------------------------------
_F0;   BEQ *
;----------------------------------------------------------------------------
	tst m6502_nz,#0xff
	ldrsb r0,[m6502_pc],#1
	addeq m6502_pc,m6502_pc,r0
;	subeq cycles,cycles,#3*CYCLE
	subeq cycles,cycles,#256
	fetch 2
;----------------------------------------------------------------------------
_F1;   SBC ($nn),Y
;----------------------------------------------------------------------------
	doIIY
	opSBC
	fetch_c 5
;----------------------------------------------------------------------------
_F5;   SBC $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opSBC
	fetch_c 4
;----------------------------------------------------------------------------
_F6;   INC $nn,X
;----------------------------------------------------------------------------
	doZIXf
	opINC
	fetch 6
;----------------------------------------------------------------------------
_F8;   SED
;----------------------------------------------------------------------------
	orr cycles,cycles,#CYC_D
	fetch 2
;----------------------------------------------------------------------------
_F9;   SBC $nnnn,Y
;----------------------------------------------------------------------------
	doAIY
	opSBC
	fetch_c 4
;----------------------------------------------------------------------------
_FD;   SBC $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opSBC
	fetch_c 4
;----------------------------------------------------------------------------
_FE;   INC $nnnn,X
;----------------------------------------------------------------------------
	doAIX
	opINC
	fetch 7
;***********************************************************以下指令是一些HACK游戏需要******************
_FF;  ISB $????,X  加的，不确定正确    激龟忍者传2无敌HACK需要
;-------------------------------------------------------------------
	doAIX		;MR_AX();
	opSBC	    ;ISB(); 
                ;MW_EA();  #define	MW_EA()		WR6502(EA,DT)  // EA .... EFFECTIVE ADDRESS
	fetch 5	    ;ADD_CYCLE(5);                                  // DT .... DATA
;------------------------------------------------------------------------
_FB;  ISB $????,X  加的，不确定正确    激龟忍者传2无敌HACK需要
;-------------------------------------------------------------------
	doAIY		;MR_AY();
	opSBC	    ;ISB(); 
                ;MW_EA();  
	fetch 5	    ;ADD_CYCLE(5);                                  
;------------------------------------------------------------------------
_14;      加的，不确定正确          激龟忍者传2无敌HACK需要
;-------------------------------------------------------------------
	add m6502_pc,m6502_pc,#1  ;R.PC++;
	fetch 4	                  ;ADD_CYCLE(4);                           
;-------------------------------------------------------------------
_67; // RRA $??                 帝国战机无敌HACK需要
;-------------------------------------------------------------------
	doZ			    ;MR_ZP(); 
	opADC           ;RRA(); 
					;MW_ZP();
	fetch 5 	    ;ADD_CYCLE(5);				
;--------------------------------------------------------------------
_03; // SLO ($??,X)              帝国战机无敌HACK需要
;-------------------------------------------------------------------
	doIIX		;MR_IX(); 
				;SLO(); 
				;MW_EA();
	fetch 8;	;ADD_CYCLE(8);
;-----------------------------------------------------------------
_07; // SLO $??
;------------------------------------------------------------------
	doZ		    ;MR_ZP(); 
				;SLO(); 
				;MW_ZP();
	fetch 5		;ADD_CYCLE(5);

;----------------------------------------------------------------------------
	IMPORT debug_6502  ;main.c
_xx;	???					;invalid opcode	无效的操作码
;----------------------------------------------------------------------------
	mov r1,#1           ;不用debug可以直接注译这两行
    bl debug_6502
	
	fetch 2

;*****************************************************************************************************

	AREA cpu_run, CODE, READONLY
run6502	PROC;r0=要运行的cpu周期*256
;----------------------------------------------------------------------------
	
	stmfd sp!,{r4-r11,lr}		;将这几个寄存器中的值保存到堆栈中
	
	ldr globalptr,=cpu_data	 ;r10   wram_globals: 读取地址
	ldr cpu_zpage,=NES_RAM			   	;r11
        ldr cpu_zpage,[cpu_zpage]       ;NES_RAM用了指针
 
	adr r1,cpuregs
	ldmia r1,{m6502_nz-m6502_pc}	;restore 6502 state恢复6502状态	 r3-r9	
	add cycles,cycles,r0	
			
	ldrb r0,cpuirqf ;cpu中断标志
	cmp r0,#0x01;
	beq CheckI      ;EQ       相等(EQual)	irq6502;

	fetch 0       ;//提取操作码并运行							   
exit_run

    ldrb r0,cpunmif ;cpu中断标志
	cmp r0,#0x01;
	beq NMI6502      ;EQ       相等(EQual)	
	
exit_nmi	
	adr r0,cpuregs
	stmia r0,{m6502_nz-m6502_pc} ;保存6502状态	  r3-r9
	
	ldmfd sp!,{r4-r11,pc}	;exit 					
    ENDP
;***************************************************************************************
NMI6502 PROC;---------------------------
    mov r0,#0
	str r0,cpunmif;清除cpu中断标志   

	ldr r12,=NMI_VECTOR		 ;NMI?	 addy
	bl Vec6502
	sub cycles,cycles,#7*256	;CYCLE=256	 6502的中断潜伏期为七 (7) 个周
                              ; 期; 这也就是说需要需要七 (7) 个周期来移入和移出一个中断
    b exit_nmi		;return 
	ENDP
;----------------------------------------------------------------------------

default_scanlinehook
   
	fetch 0
;----------------------------------------------------------
CheckI								;Check Interrupt Disable 检查中断禁用
;----------------------------------------------------------
	tst cycles,#CYC_I
	bne default_scanlinehook		;we dont want no stinkin irqs 我们不需要没有讨厌的IRQ
;----------------------------------------------------------
irq6502  
;----------------------------------------------------------
	mov r0,#0
	str r0,cpuirqf;清除cpu中断标志
	
	ldr r12,=IRQ_VECTOR
	bl Vec6502
	fetch 7    
;----------------------------------------------------------
Vec6502
;----------------------------------------------------------
	ldr r0,lastbank
	sub r0,m6502_pc,r0
	push16					;save PC

	encodeP (R)				;save P
VecCont
	push8 r0

	orr cycles,cycles,#CYC_I	;disable IRQ	禁用IRQ

	ldr r0,memmap_tbl+28	  ;7*4
;	ldrb m6502_pc,[r0,r12]!
	ldrb m6502_pc,[r0,r12]	;在数据传送之前,将偏移量加到Rn 中,其结果作为传送数据的存储地址
                            ;若使用后缀"!",则结果写回到Rn中
	add r0,r0,r12			 ;R12=0xfffc ;// 复位中断向量地址
	
	ldrb r2,[r0,#1]
	orr m6502_pc,m6502_pc,r2,lsl#8
	encodePC				;get IRQ vector得到6502 PC ROM的偏移量

	bx lr					  ; 函数返回
;----------------------------------------------------------------------------
CPU_reset PROC	;called by loadcart (r0-r9 are free to use)
;----------------------------------------------------------------------------
	str lr,[sp,#-4]!	
	
	mov m6502_a,#0
	mov m6502_x,#0
	mov m6502_y,#0
	mov m6502_nz,#0
	adr m6502_rmem,readmem_tbl ;把readmem_tbl的地址加载到m6502_rmem
	
;	ldr r0,=NES_RAM+0x100	   ;256	
		  ldr r0,=NES_RAM            ;NES_RAM用了指针
		  ldr r0,[r0]                ;
		  add r0,#0x100
  
	str r0,m6502_s		;S=0xFD (0x100-3)	  把一个寄存器按字存储到存储器中
;-------------------------------------------------------	
	mov r0,#0
	str r0,cpunmif;清除cpu中断标志
	str r0,cpuirqf  ;清除cpu中断标志
;------------------------------------------	
	mov cycles,#0		;D=0, C=0, V=0, I=1 disable IRQ.

	ldr r12,=RES_VECTOR		 ;// 复位中断向量地址
	bl Vec6502

	adr r0,cpuregs			 ;读取地址
	stmia r0,{m6502_nz-m6502_pc}	   ;保存6502状态

	ldr r1,=exit_run				  ;
	str r1,nexttimeout		  ;保存指令执行完后下一步的PC地址

	ldr pc,[sp],#4
	ENDP
;	nop
;-------------------------------------------------------------------------

   AREA rwram_code, CODE, READONLY;READWRITE**************************************
;----------------------------------------------------------------------------
;memory
;------------------------------------------------------------------------
empty_R		;读地址不正确read bad address (error)
;----------------------------------------------------------------------------	
	mov r0,r12
	mov r1,#2
    bl debug_6502
	;----------------------------------
	mov r0,#0
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr  
;----------------------------------------------------------------------------
void PROC;- - - - - - - - -空函数
	mov r0,#0	
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
	ENDP
;----------------------------------------------------------------------------
ram_R	;ram read ($0000-$1FFF)
;----------------------------------------------------------------------------
	bic addy,addy,#0x1f800		;only 0x07FF is RAM
	ldrb r0,[cpu_zpage,addy]
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
ram_W	;ram write ($0000-$1FFF)
;----------------------------------------------------------------------------
	bic addy,addy,#0x1f800		;only 0x07FF is RAM
	strb r0,[cpu_zpage,addy]   ; cpu_zpage	RN r11 ;=CPU_RAM
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
sram_R	;sram read ($6000-$7FFF)
;----------------------------------------------------------------------------
	sub r1,addy,#0x6000	
    ldr r2,memmap_tbl+12 
;	ldrb r0,[cpu_zpage,r1]
	ldrb r0,[r2,r1]
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
sram_W	;sram write ($6000-$7FFF)
;----------------------------------------------------------------------------
	sub addy,addy,#0x6000
    ldr r1,memmap_tbl+12                     
;	strb r0,[cpu_zpage,addy]
	strb r0,[r1,addy]
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
rom_R60	;rom read ($6000-$7FFF)
;----------------------------------------------------------------------------
	ldr r1,memmap_tbl+12
	ldrb r0,[r1,addy]
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
rom_R80	;rom read ($8000-$9FFF)
;----------------------------------------------------------------------------
	ldr r1,memmap_tbl+16
	ldrb r0,[r1,addy]
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
rom_RA0	;rom read ($A000-$BFFF)
;----------------------------------------------------------------------------
	ldr r1,memmap_tbl+20
	ldrb r0,[r1,addy]
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
rom_RC0	;rom read ($C000-$DFFF)
;----------------------------------------------------------------------------
	ldr r1,memmap_tbl+24
	ldrb r0,[r1,addy]
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
rom_RE0	;rom read ($E000-$FFFF)
;----------------------------------------------------------------------------
	ldr r1,memmap_tbl+28
	ldrb r0,[r1,addy]
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr

	nop
;----------------------------------------------------------------------------
;IO
   AREA io_code, CODE, READONLY ;--
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
IO_R		;I/O read
;----------------------------------------------------------------------------
	mov r2,#0x4018      ;$4018-$6000
	cmp r12,r2    	
	bhi  Read_Low              ;HI  无符号数大于  C==1 && Z==0 
		
	sub r1,r12,#0x4000	 ;addy=r12
	subs r1,r1,#0x15
	bmi empty_R		  ;读地址不正确 MI       负数(MInus)                   N==1 
	cmp r1,#3
;	ldrmi pc,[pc,r2,lsl#2]
	ldr r2,=io_read_tbl   ;//改过，加3行
	add r2,r2,r1,lsl#2			  ;<<2
	ldrmi pc,[r2]
	b empty_R          ;读地址不正确
;	nop
	
io_read_tbl
	DCD apu_4015R;void;_4015r	;4015 (sound)
	DCD joy0_R	;4016: controller 1
	DCD joy1_R	;4017: controller 2
;----------------------------------------------------------------------------
IO_W		;I/O write
;----------------------------------------------------------------------------
	mov r2,#0x4018      ;$4018-$6000
	cmp r12,r2    	
	bhi  Write_Low              ;HI  无符号数大于  C==1 && Z==0 
	
	sub r1,r12,#0x4000	   ;addy=r12
	cmp r1,#0x18
;	ldrmi pc,[pc,r2,lsl#2]
	ldr r2,=io_write_tbl   ;//改过，加3行
	add r2,r2,r1,lsl#2			  ;<<2		
	ldrmi pc,[r2]          ;//直接操作pc太他妈危险了
	b empty_R		  ;读地址不正确
 	nop
	
io_write_tbl	
	DCD apu_w;void;_4000w
	DCD apu_w;_4001w
	DCD apu_w;_4002w
	DCD apu_w;_4003w
	DCD apu_w;_4004w
	DCD apu_w;_4005w
	DCD apu_w;_4006w
	DCD apu_w;_4007w
	DCD apu_w;_4008w
	DCD apu_w;void;
	DCD apu_w;_400aw
	DCD apu_w;void;_400bw
	DCD apu_w;void;_400cw
	DCD apu_w;void
	DCD apu_w;void;_400ew
	DCD apu_w;void;_400fw
	DCD apu_w;void;_4010w
	DCD apu_w;void;_4011w
	DCD apu_w;void;_4012w
	DCD apu_w;void;_4013w
	DCD dma_W	;$4014: Sprite DMA transfer
	DCD apu_4015w;void;_4015w		 ; 声音通道切换 

	DCD joy0_W	;$4016: Joypad 0 write;joypad_write_ptr
	DCD void;joy1_W;$4017: ?
		
;-------------------------------------------------------------------------------
    IMPORT asm_Mapper_ReadLow
Read_Low  PROC;$5000-$6000  mapper->MemoryReadLow(addr);	
;------------------------------------------------------------------------------
    stmfd sp!,{r3,lr}	;LR 寄存器放栈 
	mov r0,r12
	bl asm_Mapper_ReadLow

	ldmfd sp!,{r3,lr}
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
	ENDP
;-------------------------------------------------------------------------------
    IMPORT asm_Mapper_WriteLow
Write_Low  PROC;$5000-$6000  mapper->MemoryWriteLow( data, addr);	
;------------------------------------------------------------------------------
    stmfd sp!,{r3,lr}	;LR 寄存器放栈 
	mov r1,r12
	bl asm_Mapper_WriteLow

	ldmfd sp!,{r3,lr}
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
	ENDP
;-----------------------------------------------------------------------------
	IMPORT Apu_Write  ;apu.c 
	IMPORT Apu_Write4015  ;apu.c	
;-----------------------------------------------------------------------------------
apu_w					; 0x4000--0x4013
;---------------------------------------------------------------------------------
    stmfd sp!,{r3,lr}	;LR 寄存器放栈 
	bl Apu_Write

	ldmfd sp!,{r3,lr}
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;-----------------------------------------------------------------------------------
apu_4015w
;-------------------------------------------------------------------------
	stmfd sp!,{r3,lr}	;LR 寄存器放栈      
	bl Apu_Write4015
	
	ldmfd sp!,{r3,lr}
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr

;----------------------------------------------------------------------------
    IMPORT Apu_Read4015  ;apu.c
apu_4015R	;4015
;----------------------------------------------------------------------------------	
	stmfd sp!,{r3,lr}	;LR 寄存器放栈 
	add r0,r1,#0x15
	bl Apu_Read4015
	
	ldmfd sp!,{r3,lr}
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
dma_W	;(4014)		sprite DMA transfer	精灵DMA传输	DMA访问精灵RAM：
;通过写一个值xx到这个端口，引起CPU内存地址为$xx00－$xxFF的区域传送到精灵内存 
;----------------------------------------------------------------------------
	sub cycles,cycles,#512*256
	stmfd sp!,{r3,lr}

	and r1,r0,#0xe0
	adr r2,memmap_tbl
	lsr r1,r1,#3
	ldr r2,[r2,r1]
	and r0,r0,#0xff
	add r2,r2,r0,lsl#8	;addy  r2=DMA source 源
	ldr r1,=spr_ram		;r1     DMA的 目的地	   ppu.c
		ldr r1,[r1]         ;spr_ram用了指针
		
	mov r0,#64			;256/4/8
copy_
	subs r0,r0,#1		  ;-1
	ldr r3,[r2,r0,lsl#2]
	str r3,[r1,r0,lsl#2]  ;<<2	   *4
	bne copy_

	ldmfd sp!,{r3,lr}
	orr lr,#0x01		;lr最低位置1防止进入arm状态
    bx lr
;----------------------------------------------------------------------------
    IMPORT PADdata
	IMPORT PADdata1	
joy0_W		;4016  手柄1键值 [7:0]右7 左6 下5 上4 Start3 Select2 B1 A0   )
;----------------------------------------------------------------------------
	tst r0,#1           ;0＝写，1＝读
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bxne lr            ;NE       不等（NotEqual）  
	
	ldr r1,=PADdata;   //手柄1键值  
    ldr r1,[r1]
	str r1,joy0data
	          	
	ldr r1,=PADdata1;   //手柄1键值  
    ldr r1,[r1]
	str r1,joy1data							
				
	bx lr
;-----------------------------------------------------------------------------   
joy1_W		;4017  手柄1键值 [7:0]右7 左6 下5 上4 Start3 Select2 B1 A0   )
;----------------------------------------------------------------------------
	;tst r0,#1          ; 0＝??，1＝读
	;orr lr,#0x01		;lr最低位置1防止进入arm状态
	;bxne lr  ;NE       不等（NotEqual）  	
	         
	bx lr		
;----------------------------------------------------------------------------

joy0_R		;4016
;----------------------------------------------------------------------------	
	ldr r0,joy0data	   ;串行数据  当前读取位;joy0data是键值
    mov r1,r0,lsr#1       ;>>1
	str r1,joy0data
	
	and r0,r0,#1      ;&1	
	orr r0,r0,#0x40   ;|0x40

    orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;----------------------------------------------------------------------------
joy1_R		;4017
;----------------------------------------------------------------------------
	ldr r0,joy1data	   ;串行数据  当前读取位;joy0data是键值
    mov r1,r0,lsr#1       ;>>1
	str r1,joy1data
	
	and r0,r0,#1      ;&1	
	orr r0,r0,#0x40   ;|0x80？  0xf8?
	
    orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;--------------------------------------------------------------
K6502_Read	PROC;apu  Rendering DPCM channel #5		r0=APU->ApuC5Address不确定正确*
;---------------------------------------------------------------
	   EXPORT  K6502_Read		;switch ( wAddr & 0xe000 ) apu.c
    stmfd sp!,{lr}
	
	mov r1,r0,lsr#13 ;>>13=  & 0xe000
	ldr r2,=CPU_RAM;;//存储器映象 ram+rom	
	ldr r1,[r2,r1,lsl#2]	;lookup rom ptr..查找ptr
	
    bic r0,r0,#0xe000 ;and r0,#0x1fff &0x1fff	
	ldrb r0,[r1,r0]
	
    ldmfd sp!,{lr}
	bx lr
	ENDP
	nop
;------------------------------------------------------------------------
	 AREA CPU_GPU, CODE, READONLY
	  
    IMPORT PPU_WriteToPort    ;PPU.c
	IMPORT PPU_ReadFromPort	  ;PPU.c
;------------------------------------------------------------------------------------
PPU_W
	stmfd sp!,{r3,lr}	;LR 寄存器放栈 
	mov r1,r12
	bl PPU_WriteToPort
	ldmfd sp!,{r3,lr}
	orr lr,#0x01		;lr最低位置1防止进入arm状态
	bx lr
;--------------------------------------------------------------------------------------
PPU_R
	stmfd sp!,{r3,lr}	;LR 寄存器放栈    会改变R4 
	mov r0,r12
	bl PPU_ReadFromPort	
	ldmfd sp!,{r3,lr}
    orr lr,#0x01
	bx lr
    nop
;-----------------------------------------------------------------------------------------
	AREA cpu_code, DATA, READONLY 
;-----------------------------------------------------------------------------------------		
op_table	   ;DCD 用于分配一段字内存单元 op_table内存块起始地址标号
	DCD _00,_01,_xx,_03,_xx,_05,_06,_07,_08,_09,_0A,_xx,_xx,_0D,_0E,_xx
	DCD _10,_11,_xx,_xx,_14,_15,_16,_xx,_18,_19,_xx,_xx,_xx,_1D,_1E,_xx
	DCD _20,_21,_xx,_xx,_24,_25,_26,_xx,_28,_29,_2A,_xx,_2C,_2D,_2E,_xx
	DCD _30,_31,_xx,_xx,_xx,_35,_36,_xx,_38,_39,_xx,_xx,_xx,_3D,_3E,_xx
	DCD _40,_41,_xx,_xx,_xx,_45,_46,_xx,_48,_49,_4A,_xx,_4C,_4D,_4E,_xx
	DCD _50,_51,_xx,_xx,_xx,_55,_56,_xx,_58,_59,_xx,_xx,_xx,_5D,_5E,_xx
	DCD _60,_61,_xx,_xx,_xx,_65,_66,_67,_68,_69,_6A,_xx,_6C,_6D,_6E,_xx
	DCD _70,_71,_xx,_xx,_xx,_75,_76,_xx,_78,_79,_xx,_xx,_xx,_7D,_7E,_xx
	DCD _xx,_81,_xx,_xx,_84,_85,_86,_xx,_88,_xx,_8A,_xx,_8C,_8D,_8E,_xx
	DCD _90,_91,_xx,_xx,_94,_95,_96,_xx,_98,_99,_9A,_xx,_xx,_9D,_xx,_xx
	DCD _A0,_A1,_A2,_xx,_A4,_A5,_A6,_xx,_A8,_A9,_AA,_xx,_AC,_AD,_AE,_xx
	DCD _B0,_B1,_xx,_xx,_B4,_B5,_B6,_xx,_B8,_B9,_BA,_xx,_BC,_BD,_BE,_xx
	DCD _C0,_C1,_xx,_xx,_C4,_C5,_C6,_xx,_C8,_C9,_CA,_xx,_CC,_CD,_CE,_xx
	DCD _D0,_D1,_xx,_xx,_xx,_D5,_D6,_xx,_D8,_D9,_xx,_xx,_xx,_DD,_DE,_xx
	DCD _E0,_E1,_xx,_xx,_E4,_E5,_E6,_xx,_E8,_E9,_EA,_xx,_EC,_ED,_EE,_xx
	DCD _F0,_F1,_xx,_xx,_xx,_F5,_F6,_xx,_F8,_F9,_xx,_FB,_xx,_FD,_FE,_FF
		                                                         
;---------------------------------------------------------------------------------				
	AREA wram_globals0, DATA, READWRITE
;---------------------------------------------------------------------------------		
cpu_data  
	DCD 0         ;opz #   4      //代码表地址	
  ;readmem_tbl													
	DCD ram_R	;$0000				
	DCD PPU_R	;$2000
	DCD IO_R	;$4000
	DCD sram_R	;$6000
	DCD rom_R80	;$8000
	DCD rom_RA0	;$A000
	DCD rom_RC0	;$C000
	DCD rom_RE0	;$E000
  ;writemem_tbl
	DCD ram_W	;$0000			  
	DCD PPU_W	;$2000	  r0传参数
	DCD IO_W	;$4000
	DCD sram_W	;$6000
	DCD void	;$8000
	DCD void	;$A000
	DCD void	;$C000
	DCD void	;$E000
CPU_RAM   ;memmap_tbl		存储器映象
	DCD NES_RAM		;$0000   0000-7fff	 keep $400 byte aligned for 6502 stack shit
	DCD NES_RAM		;$2000    should	  保持1024字节对齐
	DCD NES_RAM		;$4000     never
	DCD NES_SRAM;   NES_RAM-0x5800	;$6000      change改变
rommap	% 4*4			;$8000-FFFF	 memmap_tbl+16

cpustate
	;group these together for save/loadstate
	% 7*4 ;cpuregs (nz,c,a,x,y,cycles,pc)
	DCD 0 ;m6502_s:
	DCD 0 ;lastbank: 最后MEMMAP添加到PC （用于计算当前的PC ）
	DCD 0 ;nexttimeout:  jump here when cycles runs out	跳到下一个时钟周期运行
   
    DCD 0   ;rombase # 4			;//ROM开始地址
    DCD 0   ;romnumber # 4		 ;// 
    DCD 0   ;rommask # 4		   ;//ROM掩膜	rommask=romsize-1
		
	DCD 0   ;joy0data # 4	   ;//手柄1串行数据
	DCD 0   ;joy1data # 4	   ;//手柄2串行数据	
clocks		
	DCD 0	;clocksh # 4    ;//执行的时钟数 apu用
cpunmi
    DCD 0   ;cpunmif # 4      ;cpu中断标志
cpuirq
    DCD 0   ;cpuirqf # 4      ;cpu中断标志 		
;	DCW 0	DCW定义16位变量
;----------------------------------------------------------------------------
;	ALIGN           ;通过用零或空指令NOP填充，来使当前位置与一个指定的边界对齐
	END
;align 4


